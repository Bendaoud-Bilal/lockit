import {
  createEncryptedTotpItem,
  getDecryptedSecret,
  getUserTotps,
  deleteTotp,
  updateTotpState,
  getUserVaultKey,
  decryptTotpSecret,
} from "../services/totp.service.js";
import prisma from "../services/prisma.service.js";
import { ApiError } from "../utils/ApiError.js";
import { getCredentialById } from "./vault.js";

/** 
 * Save TOTP secret (generated by frontend)
 * POST /api/totp
 */
export async function saveTotp(req, res, next) {
  try {

    const {serviceName,accountName,secret,credentialId} = req.body;
    const userId = req.user.id;

    // Validation
    if (!serviceName || !accountName || !secret) {
      throw new ApiError(
        400,
        "secret, serviceName, and accountName are required"
      );
    }
    
    // Validate secret format (base32)
    const base32Regex = /^[A-Z2-7]+=*$/;
    if (!base32Regex.test(secret)) {
      throw new ApiError(400, "Invalid secret format (must be base32)");
    }

    // Save encrypted secret to database
    const totpEntry = await createEncryptedTotpItem(
      userId,
      credentialId,
      secret,
      serviceName,
      accountName,
      serviceName
    );

    res.status(201).json({
      success: true,
      message: "TOTP saved successfully",
      data: totpEntry,
    });
  } catch (error) {
    next(error);
  }
}



/**
 * Get all TOTP entries for user at session start
 * GET /api/totp/session
 */
export async function getSessionTotps(req, res, next) {
  try {
    const userId = req.user.id;

    // Get all active TOTPs with decrypted secrets
    const totpSecrets = await prisma.totpSecret.findMany({
      where: {
        credential: {
          userId: userId,
        },
        state: "active", // Only active TOTPs
      },
      include: {
        credential: {
          select: { userId: true },
        },
      },
    });

    // Get user's vault key once
    const vaultKey = await getUserVaultKey(userId);

    // Decrypt all secrets
    const decryptedTotps = totpSecrets.map((totp) => {
      const decryptedSecret = decryptTotpSecret(
        totp.secretIv,
        totp.encryptedSecret,
        totp.secretAuthTag,
        vaultKey
      );

      return {
        id: totp.id,
        credentialId: totp.credentialId,
        serviceName: totp.serviceName,
        accountName: totp.accountName,
        issuer: totp.issuer,
        secret: decryptedSecret,
        algorithm: totp.algorithm,
        digits: totp.digits,
        period: totp.period,
        state: totp.state,
        createdAt: totp.createdAt,
      };
    });

    res.status(200).json({
      success: true,
      count: decryptedTotps.length,
      data: decryptedTotps,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Get all TOTP entries (metadata only, no secrets)
 * GET /api/totp
 */
export async function getAllTotps(req, res, next) {
  try {
    const userId = req.user.id;
    const { state } = req.query; // Optional filter: ?state=active or ?state=archived

    let totps = await getUserTotps(userId);

    // Filter by state if provided
    if (state && ["active"].includes(state)) {
      totps = totps.filter((totp) => totp.state === state);
    }

    res.status(200).json({
      success: true,
      count: totps.length,
      data: totps,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Get specific TOTP with decrypted secret
 * GET /api/totp/:id
 */
export async function getTotpById(req, res, next) {
  try {
    const totpId = parseInt(req.params.id);
    const userId = req.user.id;


    if (isNaN(totpId)) {
      throw new ApiError(400, "Invalid TOTP ID");
    }

    const totp = await getDecryptedSecret(totpId, userId);

    res.status(200).json({
      success: true,
      data: totp,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Archive or activate a TOTP
 * PATCH /api/totp/:id/state
 */
export async function updateState(req, res, next) {
  try {
    const totpId = parseInt(req.params.id);
    const userId = req.user.id;
    const { state } = req.body;

    if (isNaN(totpId)) {
      throw new ApiError(400, "Invalid TOTP ID");
    }

    if (!state || !["active", "archived"].includes(state)) {
      throw new ApiError(400, "State must be 'active' or 'archived'");
    }

    const updated = await updateTotpState(totpId, userId, state);

    res.status(200).json({
      success: true,
      message: `TOTP ${state === "archived" ? "archived" : "activated"} successfully`,
      data: updated,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Delete TOTP entry
 * DELETE /api/totp/:id
 */
export async function deleteTotpEntry(req, res, next) {
  try {
    const totpId = parseInt(req.params.id);
    const userId = req.user.id;

    if (isNaN(totpId)) {
      throw new ApiError(400, "Invalid TOTP ID");
    }

    const result = await deleteTotp(totpId, userId);

    res.status(200).json({
      success: true,
      message: result.message,
    });
  } catch (error) {
    next(error);
  }
}


export async function getCredentials(req, res, next) {
  try {
    const userId = req.user.id; 
    const data = await prisma.credential.findMany({
      where: { userId },
      select: {
        id: true,
        title: true,
      },
      orderBy: { title: "asc" }
    });

    res.json({ data });
  } catch (err) {
    next(err);
  }
}
import {
  createEncryptedTotpItem,
  getDecryptedSecret,
  getUserTotps,
  deleteTotp,
  updateTotpState,
} from "../services/totp.service.js";
import prisma from "../services/prisma.service.js";
import { ApiError } from "../utils/ApiError.js";
// import { useId } from "react";


/** 
 * Save TOTP informations (generated by frontend)
 * POST /api/totp
 */
export async function saveTotp(req, res, next) {
  try {

    const {serviceName,accountName,secret,credentialId, encryptedSecret, secretIv, secretAuthTag} = req.body;
    const userId = req.user.id;

    // Validation: require serviceName and accountName, and at least one of
    // plaintext `secret` (legacy) or the encrypted secret payload.
    if (!serviceName || !accountName) {
      throw new ApiError(400, "serviceName and accountName are required");
    }

    const hasEncryptedPayload = encryptedSecret && secretIv && secretAuthTag;
    if (!hasEncryptedPayload) {
      // Enforce zero-knowledge: plaintext secrets are not accepted. The client
      // must encrypt the TOTP secret locally and submit the encrypted blob.
      throw new ApiError(400, "Encrypted TOTP payload required. Client must provide encryptedSecret, secretIv and secretAuthTag.");
    }

    // Save provided encrypted secret blob (zero-knowledge flow)
    const totpEntry = await createEncryptedTotpItem(
      userId,
      credentialId,
      { encryptedSecret, iv: secretIv, authTag: secretAuthTag },
      serviceName,
      accountName,
      serviceName
    );

    res.status(201).json({
      success: true,
      message: "TOTP saved successfully",
      data: totpEntry,
    });
  } catch (error) {
    next(error);
  }
}



/**
 * Get all TOTP entries for user at session start
 * GET /api/totp/session
 */
export async function getSessionTotps(req, res, next) {
  try {
    // For zero-knowledge, return encrypted blobs to the client and let the
    // frontend decrypt locally using the in-memory vault key. Avoid any
    // server-side decryption of user vault keys.
    const userId = req.user.id;
    let totps = await getUserTotps(userId);
    totps = totps.filter((t) => t.state === "active");

    res.status(200).json({
      success: true,
      count: totps.length,
      data: totps,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Get all TOTP entries 
 * GET /api/totp
 */
export async function getAllTotps(req, res, next) {
  try {
  
    const userId = req.user.id;
    let totps = await getUserTotps(userId);
    totps = totps.filter((totp) => totp.state === "active");
    res.status(200).json({
      success: true,
      count: totps.length,
      data: totps,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Get specific TOTP encrypted blob (client will decrypt)
 * GET /api/totp/:id
 */
export async function  getTotpByCredentialId(req, res, next) {
  try {
    const credentialId = parseInt(req.params.id);
    const userId = req.user.id;


    if (isNaN(credentialId)) {
      throw new ApiError(400, "Invalid credential ID");
    }

    const totp = await getDecryptedSecret(credentialId, userId);

    res.status(200).json({
      success: true,
      data: totp,
    });
  } catch (error) {
    next(error);
  }
}


// GET /api/totp/by-credential/:credId
// give totp linked to a credential,by a given credential id
export async function getTotpId(req, res, next) {
  try {
    const credId =parseInt(req.params.credentialId);
    const userId = req.user.id;
    if (isNaN(credId)) throw new ApiError(400, "Invalid credential ID");
     const totp = await prisma.totpSecret.findFirst({
      where: {
        credentialId: credId,
        credential: {
          userId: userId,
        },
      },
      select: { id: true },
    });
    if (!totp) {
      return res.status(404).json({
        success: false,
        message: "No TOTP found for this credential",
      });
    }

    res.status(200).json({
      success: true,
      data: totp,
    });
  } catch (error) {
    next(error);
  }
}


/**
/**
 * Get specific TOTP encrypted blob by TOTP id (client decrypts locally)
 */
export async function  getTotpById(req, res, next) {
  try {
    const totpId = parseInt(req.params.id);
    const userId = req.user.id;


    if (isNaN(totpId)) {
      throw new ApiError(400, "Invalid TOTP ID");
    }

    const totp = await getDecryptedSecret(totpId, userId);

    res.status(200).json({
      success: true,
      data: totp,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Archive or activate a TOTP
 * PATCH /api/totp/:id/state
 */
export async function updateState(req, res, next) {
  try {
    const totpId = parseInt(req.params.id);
    const userId = req.user.id;
    const { state } = req.body;

    if (isNaN(totpId)) {
      throw new ApiError(400, "Invalid TOTP ID");
    }

    if (!state || !["active", "archived"].includes(state)) {
      throw new ApiError(400, "State must be 'active' or 'archived'");
    }

    const updated = await updateTotpState(totpId, userId, state);

    res.status(200).json({
      success: true,
      message: `TOTP ${state === "archived" ? "archived" : "active"} successfully`,
      data: updated,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Delete TOTP entry
 * DELETE /api/totp/:id
 */
export async function deleteTotpEntry(req, res, next) {
  try {
    const totpId = parseInt(req.params.id);
    const userId = req.user.id;

    if (isNaN(totpId)) {
      throw new ApiError(400, "Invalid TOTP ID");
    }

    const result = await deleteTotp(totpId, userId);

    res.status(200).json({
      success: true,
      message: result.message,
    });
  } catch (error) {
    next(error);
  }
}

// gets existing credentials in vault
export async function getCredentials(req, res, next) {
  try {
    const userId = req.user.id; 
    const data = await prisma.credential.findMany({
      where: { userId },
      select: {
        id: true,
        title: true,
      },
      orderBy: { title: "asc" }
    });

    res.json({ data });
  } catch (err) {
    next(err);
  }
}
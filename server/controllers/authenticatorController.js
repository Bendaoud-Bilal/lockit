import {
  createEncryptedTotpItem,
  getDecryptedSecret,
  getUserTotps,
  deleteTotp,
  updateTotpState,
  getUserVaultKey,
  decryptTotpSecret,
} from "../services/totp.service.js";
import prisma from "../services/prisma.service.js";
import { ApiError } from "../utils/ApiError.js";
// import { useId } from "react";


/** 
 * Save TOTP informations (generated by frontend)
 * POST /api/totp
 */
export async function saveTotp(req, res, next) {
  try {

    const {serviceName,accountName,secret,credentialId} = req.body;
    const userId = req.user.id;

    // Validation
    if (!serviceName || !accountName || !secret) {
      throw new ApiError(
        400,
        "secret, serviceName, and accountName are required"
      );
    }
    
    // Validate secret format (base32)
    const base32Regex = /^[A-Z2-7]+=*$/;
    if (!base32Regex.test(secret)) {
      throw new ApiError(400, "Invalid secret format (must be base32)");
    }

    // Save encrypted secret to database
    const totpEntry = await createEncryptedTotpItem(
      userId,
      credentialId,
      secret,
      serviceName,
      accountName,
      serviceName
    );

    res.status(201).json({
      success: true,
      message: "TOTP saved successfully",
      data: totpEntry,
    });
  } catch (error) {
    next(error);
  }
}



/**
 * Get all TOTP entries for user at session start
 * GET /api/totp/session
 */
export async function getSessionTotps(req, res, next) {
  try {
    const userId = req.user.id;

    // Get all active TOTPs with decrypted secrets
    const totpSecrets = await prisma.totpSecret.findMany({
      where: {
        credential: {
          userId: userId,
        },
        state: "active", // Only active TOTPs
      },
      include: {
        credential: {
          select: { userId: true },
        },
      },
    });

    // Get user's vault key once
    const vaultKey = await getUserVaultKey(userId);

    // Decrypt all secrets
    const decryptedTotps = totpSecrets.map((totp) => {
      const decryptedSecret = decryptTotpSecret(
        totp.secretIv,
        totp.encryptedSecret,
        totp.secretAuthTag,
        vaultKey
      );

      return {
        id: totp.id,
        credentialId: totp.credentialId,
        serviceName: totp.serviceName,
        accountName: totp.accountName,
        issuer: totp.issuer,
        secret: decryptedSecret,
        algorithm: totp.algorithm,
        digits: totp.digits,
        period: totp.period,
        state: totp.state,
        createdAt: totp.createdAt,
      };
    });

    res.status(200).json({
      success: true,
      count: decryptedTotps.length,
      data: decryptedTotps,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Get all TOTP entries 
 * GET /api/totp
 */
export async function getAllTotps(req, res, next) {
  try {
  
    const userId = req.user.id;
    let totps = await getUserTotps(userId);
    totps = totps.filter((totp) => totp.state === "active");
    res.status(200).json({
      success: true,
      count: totps.length,
      data: totps,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Get specific TOTP with decrypted secret
 * GET /api/totp/:id
 */
export async function  getTotpByCredentialId(req, res, next) {
  try {
    const credentialId = parseInt(req.params.id);
    const userId = req.user.id;


    if (isNaN(credentialId)) {
      throw new ApiError(400, "Invalid credential ID");
    }

    const totp = await getDecryptedSecret(credentialId, userId);

    res.status(200).json({
      success: true,
      data: totp,
    });
  } catch (error) {
    next(error);
  }
}


// GET /api/totp/by-credential/:credId
// give totp linked to a credential,by a given credential id
export async function getTotpId(req, res, next) {
  try {
    const credId =parseInt(req.params.credentialId);
    const userId = req.user.id;
    if (isNaN(credId)) throw new ApiError(400, "Invalid credential ID");
     const totp = await prisma.totpSecret.findFirst({
      where: {
        credentialId: credId,
        credential: {
          userId: userId,
        },
      },
      select: { id: true },
    });
    if (!totp) {
      return res.status(404).json({
        success: false,
        message: "No TOTP found for this credential",
      });
    }

    res.status(200).json({
      success: true,
      data: totp,
    });
  } catch (error) {
    next(error);
  }
}


/**
 * 
 * gets totp infos for a giver totp id 
 * 
 * 
 */

export async function  getTotpById(req, res, next) {
  try {
    const totpId = parseInt(req.params.id);
    const userId = req.user.id;


    if (isNaN(totpId)) {
      throw new ApiError(400, "Invalid TOTP ID");
    }

    const totp = await getDecryptedSecret(totpId, userId);

    res.status(200).json({
      success: true,
      data: totp,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Archive or activate a TOTP
 * PATCH /api/totp/:id/state
 */
export async function updateState(req, res, next) {
  try {
    const totpId = parseInt(req.params.id);
    const userId = req.user.id;
    const { state } = req.body;

    if (isNaN(totpId)) {
      throw new ApiError(400, "Invalid TOTP ID");
    }

    if (!state || !["active", "archived"].includes(state)) {
      throw new ApiError(400, "State must be 'active' or 'archived'");
    }

    const updated = await updateTotpState(totpId, userId, state);

    res.status(200).json({
      success: true,
      message: `TOTP ${state === "archived" ? "archived" : "active"} successfully`,
      data: updated,
    });
  } catch (error) {
    next(error);
  }
}

/**
 * Delete TOTP entry
 * DELETE /api/totp/:id
 */
export async function deleteTotpEntry(req, res, next) {
  try {
    const totpId = parseInt(req.params.id);
    const userId = req.user.id;

    if (isNaN(totpId)) {
      throw new ApiError(400, "Invalid TOTP ID");
    }

    const result = await deleteTotp(totpId, userId);

    res.status(200).json({
      success: true,
      message: result.message,
    });
  } catch (error) {
    next(error);
  }
}

// gets existing credentials in vault
export async function getCredentials(req, res, next) {
  try {
    const userId = req.user.id; 
    const data = await prisma.credential.findMany({
      where: { userId },
      select: {
        id: true,
        title: true,
      },
      orderBy: { title: "asc" }
    });

    res.json({ data });
  } catch (err) {
    next(err);
  }
}